#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "utils.h"

char* get_last_line_and_remove_from_original(char* str) {
    char* last_line = NULL;
    // Find the last occurrence of '\n' in the string
    char* last_newline = strrchr(str, '\n');
    if (last_newline != NULL) {
        // Extract the last line
        last_line = strdup(last_newline + 1);
        // Remove the last line from the original string
        *last_newline = '\0';
    }
    return last_line;
}
void remove_trailing_newline(char *str) {
    int len = strlen(str);
    // Check if the last character is a newline
    if (len > 0 && str[len - 1] == '\n') {
        // Replace it with a null terminator
        str[len - 1] = '\0';
    }
}

int do_qwd()
{
    info("Running `git status`");
    system("git status");

    info(
        "Will execute these commands (destructive):\n"
        "git add .\n"
        "git commit -m \"this is a dev commit\" -m \"<AUTO-GENERATED>\"\n"
        "git branch\n"
        "git status"
    );
    printf("Press Enter to continue, CTRL+C to abort\n");
    
    char usrInput[256];
    if (fgets(usrInput, sizeof(usrInput), stdin) == NULL) {
        // Handle CTRL+C here if needed
        return 1; // Exit with an error code
    }
    debug("Running...");

    info("Running `git add .`");
    system("git add .");

    // <capturing>

    FILE *fp;
    char buffer[1024];
    char *output = NULL;
    size_t output_size = 0;

    fp = popen("git diff --cached --stat --compact-summary", "r");

    if (fp == NULL) {
        perror("popen");
        return 1;
    }
    
    // Read the output in chunks
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        size_t chunk_size = strlen(buffer);
        output = realloc(output, output_size + chunk_size + 1);
        
        if (output == NULL) {
            perror("realloc");
            return 1;
        }
        
        strcpy(output + output_size, buffer);
        output_size += chunk_size;
    }    
    // Close the file pointer
    pclose(fp);


    info("Running `git commit -m \"this is a dev commit\" -m \"<AUTO-GENERATED>\"`");
    remove_trailing_newline(output);  // This is the problem causing why changing the last line seems to have failed.
    char command[102400];
    char *line;
    FILE *pipe;
    char *last_line = output;
    char *current = output;
    while (*current) {
        if (*current == '\n') {
            last_line = current + 1;  // Move to the next character after the newline
        }
        current++;
    }
    char *lastNewline = strrchr(output, '\n');
    if (lastNewline != NULL) {
        // Null-terminate the string at the last newline character
        *lastNewline = '\0';
    }
    sprintf(command, "git commit -m \"this is a dev commit: %s\"", last_line + 1);
    line = strtok(output, "\n");
    while (line != NULL) {
        sprintf(command + strlen(command), " -m \"%s\"", line);
        line = strtok(NULL, "\n");
    }
    pipe = popen(command, "r");
    if (pipe == NULL) {
        printf("Failed to run command\n");
        return 1;
    }
    pclose(pipe);
    free(output);

    info("Running `git branch`");
    system("git branch");

    info("Running `git status`");
    system("git status");
}

int do_d()
{
    info("Running `git status`");
    system("git status");
    info("Running `git branch`");
    system("git branch");

    // confirmation
    info(
        "Will execute these commands (destructive):\n"
        "git checkout -b up"
    );
    printf("Press Enter to continue, CTRL+C to abort\n");
    char usrInput[256];
    if (fgets(usrInput, sizeof(usrInput), stdin) == NULL) {
        // Handle CTRL+C here if needed
        return 1; // Exit with an error code
    }
    debug("Running...");
    
    info("Running `git checkout -b up`");
    system("git checkout -b up");
    return 0;
}

int do_dwd()
{
    info("Running `git status`");
    system("git status");
    info("Running `git branch`");
    system("git branch");

    // confirmation
    info(
        "Will execute these commands (destructive):\n"
        "git checkout main\n"
        "git pull\n"
        "git branch -D up\n"
        "git branch"
    );
    printf("Press Enter to continue, CTRL+C to abort\n");
    char usrInput[256];
    if (fgets(usrInput, sizeof(usrInput), stdin) == NULL) {
        // Handle CTRL+C here if needed
        return 1; // Exit with an error code
    }
    debug("Running...");
    
    info("Running `git checkout main`");
    system("git checkout main");
    
    info("Running `git pull`");
    system("git pull");
    
    info("Running `git branch -D up`");
    system("git branch -D up");
    
    info("Running `git branch`");
    system("git branch");

    return 0;
}

int main(int argc, char *argv[]) {

    struct Logger logger;
    logger.debug = debug;
    logger.info = info;
    logger.warning = warning;
    logger.error = error;

    if (argc == 1) {
        printf(
            "USAGE\n"
            "\n"
            "#Safe commands\n"
            "q   : git rev-list --count HEAD\n"
            "qw  : git branch\n"
            "w   : git log -3\n"
            "wd  : git diff --cached\n"
            "ww  : git status\n"
            "wdwd: git diff --cached --stat --compact-summary\n"
            "\n"
            "#Destructive\n"
            "qwd: make a commit\n"
            "d  : make new branch named 'up'\n"
            "dd : git push origin up\n"
            "dwd: back to main branch\n"
        );
        return 0;
    }

    char *command = argv[1];

    if (strcmp(command, "q") == 0) {
        info("git rev-list --count HEAD");
        system("git rev-list --count HEAD");
    } else if (strcmp(command, "qw") == 0) {
        info("git branch");
        system("git branch");
    } else if (strcmp(command, "w") == 0) {
        info("git log -3");
        system("git log -3");
    } else if (strcmp(command, "wd") == 0) {
        info("git diff --cached");
        system("git diff --cached");
    } else if (strcmp(command, "ww") == 0) {
        info("git status");
        system("git status");
    } else if (strcmp(command, "wdwd") == 0) {
        info("git diff --cached --stat --compact-summary");
        system("git diff --cached --stat --compact-summary");

    } else if (strcmp(command, "qwd") == 0) {
        do_qwd();

    } else if (strcmp(command, "d") == 0) {
        do_d();

    } else if (strcmp(command, "dd") == 0) {
        info("git push origin up");
        system("git push origin up");

    } else if (strcmp(command, "dwd") == 0) {
        do_dwd();

    } else {
        printf("Invalid command: %s\n", command);
        return 1;
    }

    return 0;
}
